/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/v1/admin/forgetting:run": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** `POST /api/v1/admin/forgetting:run` */
        post: operations["admin.runForgetting"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/containers/{tag}/graph": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/containers/{tag}/graph`
         * @description Returns the knowledge graph for all memories within a container.
         */
        get: operations["graph.getContainer"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/conversations:ingest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/conversations:ingest`
         * @description Ingests a conversation, extracts memories via LLM, runs contradiction
         *     detection and deduplication, then persists the resulting memories.
         */
        post: operations["conversation.ingest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/documents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/documents`
         * @description Lists documents with cursor-based pagination. Supports filtering by
         *     `containerTags` query parameter.
         */
        get: operations["documents.list"];
        put?: never;
        /**
         * `POST /api/v1/documents`
         * @description Creates a new document and queues it for async ingestion.
         *     Returns 202 Accepted with `documentId` and `ingestionId`.
         */
        post: operations["documents.create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/documents/{documentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/documents/{documentId}`
         * @description Retrieves a full document by ID. Also checks custom_id as fallback.
         */
        get: operations["documents.get"];
        put?: never;
        post?: never;
        /**
         * `DELETE /api/v1/documents/{documentId}`
         * @description Deletes a document by ID. Also tries custom_id as fallback.
         */
        delete: operations["documents.delete"];
        options?: never;
        head?: never;
        /**
         * `PATCH /api/v1/documents/{documentId}`
         * @description Updates document metadata, title, or container tags.
         */
        patch: operations["documents.update"];
        trace?: never;
    };
    "/api/v1/documents:batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/documents:batch`
         * @description Creates multiple documents in a single request and queues them for
         *     async ingestion. Returns 202 Accepted with an array of
         *     `{ documentId, ingestionId }` pairs.
         */
        post: operations["documents.batch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/documents:upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/documents:upload`
         * @description Accepts a multipart form with a `file` field and optional `containerTag`.
         *     Creates a document from the uploaded file and queues it for async ingestion.
         *     Returns 202 Accepted with `{ documentId, ingestionId }`.
         */
        post: operations["documents.upload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** `GET /api/v1/health` */
        get: operations["health.get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/ingestions/{ingestionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/ingestions/{ingestionId}`
         * @description Polls the ingestion status for a document. Since `ingestionId` maps 1:1
         *     to `documentId`, this is effectively a status-only document lookup.
         */
        get: operations["documents.getIngestionStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/memories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/memories`
         * @description Lists memories with cursor-based pagination. Requires `containerTag` query
         *     parameter since the DB layer does not support unscoped memory listing.
         */
        get: operations["memories.list"];
        put?: never;
        /** `POST /api/v1/memories` */
        post: operations["memories.create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/memories/{memoryId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** `GET /api/v1/memories/{memoryId}` */
        get: operations["memories.get"];
        put?: never;
        post?: never;
        /** `DELETE /api/v1/memories/{memoryId}` */
        delete: operations["memories.forgetById"];
        options?: never;
        head?: never;
        /** `PATCH /api/v1/memories/{memoryId}` */
        patch: operations["memories.update"];
        trace?: never;
    };
    "/api/v1/memories/{memoryId}/graph": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * `GET /api/v1/memories/{memoryId}/graph`
         * @description Returns the knowledge graph neighborhood around a specific memory.
         */
        get: operations["graph.getMemory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/memories:forget": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/memories:forget`
         * @description Content-based forget: finds a memory by content within a container and
         *     marks it as forgotten.
         */
        post: operations["memories.forget"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile:compute": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/profile:compute`
         * @description Computes or retrieves a user profile from accumulated memories.
         *     Uses the full `MemoryService::get_profile` pipeline (narrative generation,
         *     compaction, search) and then maps the resulting `UserProfile` into the
         *     v1 `ProfileResponse` DTO.
         */
        post: operations["profile.compute"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * `POST /api/v1/search`
         * @description Unified search endpoint. Uses `scope` to determine which indices to query:
         *     - `documents` → document chunk search
         *     - `memories` → memory-only search
         *     - `hybrid` (default) → both documents and memories, deduplicated
         */
        post: operations["search.search"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Structured error payload within the API envelope.
         *
         *     ```json
         *     { "code": "not_found", "message": "Memory mem_abc123 not found" }
         *     ```
         */
        ApiError: {
            /** @description Machine-readable error classification. */
            code: components["schemas"]["ErrorCode"];
            /**
             * @description Human-readable description safe to display to end users.
             *     Internal implementation details are never included.
             */
            message: string;
        };
        /**
         * @description Request body for `POST /v1/documents/batch`.
         *
         *     Creates multiple documents in a single request.
         */
        BatchCreateDocumentRequest: {
            /** @description Default container tag applied to all documents in the batch. */
            containerTag?: string | null;
            /** @description List of documents to create (1–600 items). */
            documents: components["schemas"]["BatchDocumentItem"][];
            /** @description Default metadata applied to all documents in the batch. */
            metadata: Record<string, never>;
        };
        /** @description Response body for `POST /v1/documents/batch`. */
        BatchCreateDocumentResponse: {
            /** @description Results for each document in the batch, in order. */
            documents: components["schemas"]["CreateDocumentResponse"][];
        };
        /** @description A single document within a batch create request. */
        BatchDocumentItem: {
            /** @description The document content. */
            content: string;
            /** @description Client-provided identifier for this document. */
            customId?: string | null;
            /** @description When `true`, extract memories from this document after processing. */
            extractMemories?: boolean | null;
            /** @description Metadata specific to this document (overrides batch-level metadata). */
            metadata: Record<string, never>;
        };
        /** @description A chunk within a document search result. */
        ChunkResult: {
            content: string;
            /** Format: float */
            rerankScore?: number | null;
            /** Format: float */
            score: number;
        };
        /** @description Request body for `POST /v1/profile`. */
        ComputeProfileRequest: {
            /** @description Container tag identifying the user/entity. */
            containerTag: string;
            /** @description Generate a narrative summary. */
            generateNarrative?: boolean | null;
            /** @description Include dynamic (episode-based) facts. */
            includeDynamic?: boolean | null;
            /**
             * Format: int32
             * @description Maximum number of facts to include.
             */
            limit?: number | null;
            /** @description Optional search query to filter relevant facts. */
            q?: string | null;
            /**
             * Format: float
             * @description Minimum similarity threshold for query-based filtering.
             */
            threshold?: number | null;
        };
        /** @description Request body for `POST /v1/memories:forget` (content-based forget). */
        ContentForgetRequest: {
            /** @description Container tag to scope the search. */
            containerTag: string;
            /** @description The memory content to search for and forget. */
            content: string;
            /** @description Reason for forgetting (stored for audit trail). */
            reason?: string | null;
        };
        /**
         * @description Request body for `POST /v1/conversation`.
         *
         *     Ingests a conversation and extracts memories from it.
         */
        ConversationIngestRequest: {
            /** @description Container tag for multi-tenant isolation. */
            containerTag: string;
            memoryType?: null | components["schemas"]["V1MemoryType"];
            /** @description Conversation messages to process. */
            messages: components["schemas"]["ConversationMessageDto"][];
            /** @description Session ID for grouping related conversations. */
            sessionId?: string | null;
        };
        /** @description Response for `POST /v1/conversation`. */
        ConversationIngestResponse: {
            /**
             * Format: int32
             * @description Number of memories extracted from the conversation.
             */
            memoriesExtracted: number;
            /** @description IDs of the extracted memories. */
            memoryIds: string[];
            /** @description Session ID (generated if not provided in request). */
            sessionId: string;
        };
        /** @description A single message within a conversation. */
        ConversationMessageDto: {
            /** @description Message content text. */
            content: string;
            /** @description Message role (e.g. `"user"`, `"assistant"`, `"system"`). */
            role: string;
            /** @description When this message was sent. */
            timestamp?: string | null;
        };
        /**
         * @description Request body for `POST /v1/documents`.
         *
         *     Creates a new document and queues it for async ingestion.
         */
        CreateDocumentRequest: {
            /** @description Optional container tag for multi-tenant isolation. */
            containerTag?: string | null;
            /** @description The document content (text, URL, or base64-encoded file). */
            content: string;
            /** @description Content type hint for base64-encoded files (e.g. `"pdf"`, `"docx"`). */
            contentType?: string | null;
            /** @description Client-provided identifier for idempotency or external linking. */
            customId?: string | null;
            /** @description When `true`, extract memories from document content after processing. */
            extractMemories?: boolean | null;
            /** @description Arbitrary key-value metadata attached to the document. */
            metadata: Record<string, never>;
        };
        /**
         * @description Response body for `POST /v1/documents` — async ingestion accepted.
         *
         *     Wire format:
         *     ```json
         *     { "documentId": "V1StGXR8_Z5jdHi6B-myT", "ingestionId": "550e8400-..." }
         *     ```
         */
        CreateDocumentResponse: {
            /** @description The assigned document ID (nanoid, 21 chars). */
            documentId: string;
            /** @description The ingestion tracking ID (UUID v4). */
            ingestionId: string;
        };
        /** @description Request body for `POST /v1/memories`. */
        CreateMemoryRequest: {
            /** @description Container tag for multi-tenant isolation. */
            containerTag: string;
            /** @description The memory content text. */
            content: string;
            memoryType?: null | components["schemas"]["V1MemoryType"];
            /** @description Arbitrary key-value metadata. */
            metadata: Record<string, never>;
        };
        /**
         * @description Cursor-based pagination parameters accepted by list endpoints.
         *
         *     - `limit` defaults to 20 and is clamped to `1..=100`.
         *     - `cursor` is an opaque base64 string from a previous `ResponseMeta.nextCursor`.
         *       Passing an invalid cursor returns `400 invalid_request`.
         */
        CursorPagination: {
            /** @description Opaque pagination cursor from a previous response. */
            cursor?: string | null;
            /**
             * Format: int32
             * @description Maximum number of items to return. Clamped to `1..=100`, defaults to 20.
             */
            limit?: number;
        };
        DatabaseStatus: {
            status: string;
        };
        /** @description Full document response for `GET /v1/documents/{documentId}`. */
        DocumentResponse: {
            /**
             * Format: int32
             * @description Number of chunks created from this document.
             */
            chunkCount: number;
            /** @description Container tags for multi-tenant isolation. */
            containerTags: string[];
            /** @description Document content. */
            content?: string | null;
            /** @description When the document was created. */
            createdAt: string;
            /** @description Client-provided identifier. */
            customId?: string | null;
            /** @description Document type classification. */
            docType: components["schemas"]["V1DocumentType"];
            /** @description Unique document ID (nanoid, 21 chars). */
            documentId: string;
            /** @description Error message if ingestion failed. */
            errorMessage?: string | null;
            /** @description Current ingestion status. */
            ingestionStatus: components["schemas"]["IngestionStatus"];
            /** @description Attached metadata. */
            metadata: Record<string, never>;
            /** @description Auto-generated summary. */
            summary?: string | null;
            /** @description Document title (may be auto-extracted). */
            title?: string | null;
            /** @description When the document was last updated. */
            updatedAt: string;
            /** @description Source URL (if document was fetched from a URL). */
            url?: string | null;
        };
        /** @description Document match within search results. */
        DocumentSearchResult: {
            /** @description Matched chunks (if `include.chunks` was true). */
            chunks?: components["schemas"]["ChunkResult"][];
            content?: string | null;
            createdAt: string;
            docType?: null | components["schemas"]["V1DocumentType"];
            /** @description The matched document ID. */
            documentId: string;
            metadata: Record<string, never>;
            /**
             * Format: float
             * @description Reranking score (if reranking was applied).
             */
            rerankScore?: number | null;
            /**
             * Format: float
             * @description Vector similarity score.
             */
            score: number;
            summary?: string | null;
            title?: string | null;
            updatedAt: string;
        };
        /** @description Summary document for list responses — lighter than full `DocumentResponse`. */
        DocumentSummaryResponse: {
            /** @description Container tags. */
            containerTags: string[];
            /** @description When the document was created. */
            createdAt: string;
            /** @description Client-provided identifier. */
            customId?: string | null;
            /** @description Document type. */
            docType: components["schemas"]["V1DocumentType"];
            /** @description Unique document ID. */
            documentId: string;
            /** @description Current ingestion status. */
            ingestionStatus: components["schemas"]["IngestionStatus"];
            /** @description Attached metadata. */
            metadata: Record<string, never>;
            /** @description Document title. */
            title?: string | null;
            /** @description When the document was last updated. */
            updatedAt: string;
        };
        EmbeddingsStatus: {
            dimensions: number;
            model: string;
            status: string;
        };
        /**
         * @description Machine-readable error code included in every error response.
         *
         *     Serialized as a snake_case string on the wire (e.g. `"invalid_request"`).
         *     Each variant maps to a fixed HTTP status code via [`ErrorCode::status`].
         * @enum {string}
         */
        ErrorCode: "invalid_request" | "unauthorized" | "not_found" | "conflict" | "internal_error" | "not_implemented";
        /** @description Request body for `DELETE /v1/memories/{memoryId}`. */
        ForgetMemoryRequest: {
            /** @description Reason for forgetting (stored for audit trail). */
            reason?: string | null;
        };
        /** @description Response for `DELETE /v1/memories/{memoryId}`. */
        ForgetMemoryResponse: {
            /** @description Whether the memory was successfully forgotten. */
            forgotten: boolean;
            /** @description The memory ID that was forgotten. */
            memoryId: string;
        };
        /** @description Response for `POST /v1/admin/run-forgetting`. */
        ForgettingRunResponse: {
            /**
             * Format: int32
             * @description Number of memories evaluated for forgetting.
             */
            memoriesEvaluated: number;
            /**
             * Format: int32
             * @description Number of memories forgotten in this cycle.
             */
            memoriesForgotten: number;
        };
        /** @description An edge (link) in the knowledge graph response. */
        GraphEdgeResponse: {
            /** @description Source node ID. */
            source: string;
            /** @description Target node ID. */
            target: string;
            /** @description Relationship type. */
            type: components["schemas"]["GraphEdgeType"];
        };
        /**
         * @description Edge type in the knowledge graph.
         *
         *     Wire format: lowercase string.
         * @enum {string}
         */
        GraphEdgeType: "updates" | "relatesTo" | "conflictsWith" | "derivedFrom" | "sources";
        /** @description A node in the knowledge graph response. */
        GraphNodeResponse: {
            /** @description Node identifier (memory ID or document ID). */
            id: string;
            /** @description Additional visualization metadata. */
            metadata: Record<string, never>;
            /** @description Node classification. */
            type: components["schemas"]["GraphNodeType"];
        };
        /**
         * @description Node type in the knowledge graph.
         *
         *     Wire format: `"memory"` or `"document"`.
         * @enum {string}
         */
        GraphNodeType: "memory" | "document";
        /** @description Graph response for `GET /v1/memories/{memoryId}/graph` and `GET /v1/containers/{tag}/graph`. */
        GraphResponse: {
            /** @description Graph edges (links between nodes). */
            links: components["schemas"]["GraphEdgeResponse"][];
            /** @description Graph nodes. */
            nodes: components["schemas"]["GraphNodeResponse"][];
        };
        /** @description Health data returned inside the v1 envelope. */
        HealthData: {
            database: components["schemas"]["DatabaseStatus"];
            embeddings: components["schemas"]["EmbeddingsStatus"];
            llm: components["schemas"]["LlmStatus"];
            reranker: components["schemas"]["RerankerStatus"];
            status: string;
            version: string;
        };
        /** @description Hybrid search result — can represent either a memory or a chunk. */
        HybridSearchResultResponse: {
            chunk?: string | null;
            documentId?: string | null;
            id: string;
            memory?: string | null;
            metadata: Record<string, never>;
            /** Format: float */
            rerankScore?: number | null;
            /** Format: float */
            similarity: number;
            updatedAt: string;
        };
        /**
         * @description Simplified ingestion status for v1 API.
         *
         *     Maps from the internal `ProcessingStatus` (which has many intermediate
         *     states) to four user-facing states.
         *
         *     Wire format: `"queued"`, `"processing"`, `"completed"`, or `"failed"`.
         * @enum {string}
         */
        IngestionStatus: "queued" | "processing" | "completed" | "failed";
        /** @description Ingestion status for a single document (used in status polling). */
        IngestionStatusResponse: {
            /** @description When the document was created. */
            createdAt: string;
            /** @description Document ID. */
            documentId: string;
            /** @description Current ingestion status. */
            status: components["schemas"]["IngestionStatus"];
            /** @description Document title (if available). */
            title?: string | null;
        };
        /** @description Query parameters for `GET /v1/documents` (list endpoint). */
        ListDocumentsQuery: {
            /** @description Filter by container tags. */
            containerTags?: string[] | null;
            /** @description Opaque cursor for pagination. */
            cursor?: string | null;
            /**
             * Format: int32
             * @description Maximum results per page (default 20, max 100).
             */
            limit?: number | null;
        };
        /**
         * @description Response wrapper for document list endpoints.
         *
         *     Pagination is handled by the envelope's `meta.nextCursor` / `meta.total`.
         */
        ListDocumentsResponse: {
            /** @description Documents matching the query. */
            documents: components["schemas"]["DocumentSummaryResponse"][];
        };
        /** @description Query parameters for `GET /v1/memories`. */
        ListMemoriesQuery: {
            /** @description Filter by container tag. */
            containerTag?: string | null;
            /** @description Opaque cursor for pagination. */
            cursor?: string | null;
            /**
             * Format: int32
             * @description Maximum results per page (default 20, max 100).
             */
            limit?: number | null;
        };
        /**
         * @description Memory list response wrapper.
         *
         *     Pagination is handled by the envelope's `meta.nextCursor` / `meta.total`.
         */
        ListMemoriesResponse: {
            memories: components["schemas"]["MemoryResponse"][];
        };
        LlmStatus: {
            model?: string | null;
            provider?: string | null;
            status: string;
        };
        /** @description Full memory response for `GET /v1/memories/{memoryId}`. */
        MemoryResponse: {
            /**
             * Format: double
             * @description Confidence score (0.0–1.0).
             */
            confidence?: number | null;
            /** @description Container tag. */
            containerTag?: string | null;
            /** @description The memory content text. */
            content: string;
            /** @description When the memory was created. */
            createdAt: string;
            /** @description Whether this memory has been forgotten (soft-deleted). */
            isForgotten: boolean;
            /** @description Whether this memory was derived by inference. */
            isInference: boolean;
            /** @description Whether this is the latest version. */
            isLatest: boolean;
            /** @description Whether this memory is pinned (never auto-forgotten). */
            isStatic: boolean;
            /** @description Unique memory ID (nanoid, 21 chars). */
            memoryId: string;
            /** @description Memory type classification. */
            memoryType: components["schemas"]["V1MemoryType"];
            /** @description Attached metadata. */
            metadata: Record<string, never>;
            /** @description When the memory was last updated. */
            updatedAt: string;
            /**
             * Format: int32
             * @description Version number (incremented on contradiction resolution).
             */
            version: number;
        };
        /** @description Memory match within search results. */
        MemorySearchResult: {
            content?: string | null;
            /** @description The matched memory ID. */
            memoryId: string;
            metadata: Record<string, never>;
            /** Format: float */
            rerankScore?: number | null;
            /**
             * Format: float
             * @description Vector similarity score.
             */
            similarity: number;
            updatedAt: string;
            /** Format: int32 */
            version?: number | null;
        };
        /** @description A single fact within a profile. */
        ProfileFactResponse: {
            /**
             * Format: double
             * @description Confidence score (0.0–1.0).
             */
            confidence?: number | null;
            /** @description The fact content. */
            content: string;
            /** @description When this fact was first recorded. */
            createdAt: string;
        };
        /** @description Profile response for `POST /v1/profile`. */
        ProfileResponse: {
            /** @description Container tag this profile belongs to. */
            containerTag: string;
            /** @description Temporal/episode-based information. */
            dynamicFacts: components["schemas"]["ProfileFactResponse"][];
            /** @description When the profile was last computed. */
            lastUpdated: string;
            /** @description AI-generated narrative summary of the user. */
            narrative?: string | null;
            /** @description Long-lived factual information. */
            staticFacts: components["schemas"]["ProfileFactResponse"][];
            /**
             * Format: int32
             * @description Total number of memories used to compute this profile.
             */
            totalMemories: number;
        };
        RerankerStatus: {
            enabled: boolean;
            model?: string | null;
            status: string;
        };
        /**
         * @description Pagination metadata included in list responses.
         *
         *     Field names serialize as camelCase on the wire (`nextCursor`, `total`).
         */
        ResponseMeta: {
            /**
             * @description Opaque cursor to pass as `cursor` in the next request. `None` means
             *     there are no more results.
             */
            nextCursor?: string | null;
            /**
             * Format: int64
             * @description Total number of matching items (when cheaply available).
             */
            total?: number | null;
        };
        /** @description Flags controlling which data to include in search results. */
        SearchIncludeFlags: {
            /** @description Include individual chunks in document results (default: false). */
            chunks?: boolean;
            /** @description Include document data in results (default: true). */
            documents?: boolean;
        };
        /** @description Request body for `POST /v1/search`. */
        SearchRequest: {
            /** @description Filter by container tags. */
            containerTags?: string[] | null;
            /** @description Which data to include in results. */
            include?: components["schemas"]["SearchIncludeFlags"];
            /**
             * Format: int32
             * @description Maximum number of results to return.
             */
            limit?: number | null;
            /** @description The search query string. */
            q: string;
            /** @description Enable cross-encoder reranking. */
            rerank?: boolean | null;
            /** @description Which indices to search. */
            scope?: components["schemas"]["SearchScope"];
            /**
             * Format: float
             * @description Minimum similarity threshold (0.0–1.0).
             */
            threshold?: number | null;
        };
        /** @description Unified search response for `POST /v1/search`. */
        SearchResponse: {
            /** @description Combined search results (documents and/or memories based on scope). */
            results: components["schemas"]["SearchResultItem"][];
            /**
             * Format: int64
             * @description Query execution time in milliseconds.
             */
            timingMs: number;
            /**
             * Format: int32
             * @description Total number of matching results.
             */
            total: number;
        };
        /** @description A single item in the search results — can be a document or memory hit. */
        SearchResultItem: (components["schemas"]["DocumentSearchResult"] & {
            /** @enum {string} */
            type: "document";
        }) | (components["schemas"]["MemorySearchResult"] & {
            /** @enum {string} */
            type: "memory";
        });
        /**
         * @description Search scope determines which indices to query.
         *
         *     Wire format: `"documents"`, `"memories"`, or `"hybrid"`.
         * @enum {string}
         */
        SearchScope: "documents" | "memories" | "hybrid";
        /** @description Request body for `PATCH /v1/documents/{documentId}`. */
        UpdateDocumentRequest: {
            /** @description Updated container tags. */
            containerTags?: string[] | null;
            /** @description Updated metadata (replaces existing metadata). */
            metadata: Record<string, never>;
            /** @description Updated document title. */
            title?: string | null;
        };
        /** @description Request body for `PATCH /v1/memories/{memoryId}`. */
        UpdateMemoryRequest: {
            /** @description The new memory content (replaces existing). */
            content: string;
            /** @description Pin this memory so it's never forgotten. */
            isStatic?: boolean | null;
            /** @description Arbitrary metadata update. */
            metadata: Record<string, never>;
        };
        /** @description Response for `PATCH /v1/memories/{memoryId}`. */
        UpdateMemoryResponse: {
            /** @description The updated content. */
            content: string;
            /** @description When the update was created. */
            createdAt: string;
            /** @description The memory ID. */
            memoryId: string;
            /** @description Parent memory ID (if this is an update to a previous version). */
            parentMemoryId?: string | null;
            /**
             * Format: int32
             * @description The new version number.
             */
            version: number;
        };
        /**
         * @description Document type classification for v1 API.
         *
         *     Wire format: lowercase string (e.g. `"text"`, `"pdf"`, `"webpage"`).
         * @enum {string}
         */
        V1DocumentType: "text" | "pdf" | "webpage" | "image" | "video" | "audio" | "markdown" | "code" | "csv" | "docx" | "pptx" | "xlsx" | "unknown";
        /**
         * @description Memory type classification for v1 API.
         *
         *     Wire format: lowercase string (`"fact"`, `"preference"`, `"episode"`).
         * @enum {string}
         */
        V1MemoryType: "fact" | "preference" | "episode";
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "admin.runForgetting": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Forgetting cycle completed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ForgettingRunResponse"];
                };
            };
        };
    };
    "graph.getContainer": {
        parameters: {
            query?: {
                /** @description Maximum number of memory nodes to return (default: 100). */
                maxNodes?: number | null;
            };
            header?: never;
            path: {
                /** @description Container tag */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Container graph */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GraphResponse"];
                };
            };
        };
    };
    "conversation.ingest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConversationIngestRequest"];
            };
        };
        responses: {
            /** @description Conversation ingested */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationIngestResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.list": {
        parameters: {
            query?: {
                /** @description Filter by container tags. */
                containerTags?: string[] | null;
                /** @description Maximum results per page (default 20, max 100). */
                limit?: number | null;
                /** @description Opaque cursor for pagination. */
                cursor?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Documents listed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListDocumentsResponse"];
                };
            };
        };
    };
    "documents.create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDocumentRequest"];
            };
        };
        responses: {
            /** @description Document accepted for processing */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateDocumentResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Document ID or custom ID */
                documentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Document found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentResponse"];
                };
            };
            /** @description Document not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Document ID or custom ID */
                documentId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Document deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            /** @description Document not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Document ID */
                documentId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateDocumentRequest"];
            };
        };
        responses: {
            /** @description Document updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentResponse"];
                };
            };
            /** @description Document not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchCreateDocumentRequest"];
            };
        };
        responses: {
            /** @description Batch accepted for processing */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchCreateDocumentResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "documents.upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description File upload with optional containerTag and metadata fields */
        requestBody: {
            content: {
                "multipart/form-data": string;
            };
        };
        responses: {
            /** @description Upload accepted for processing */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateDocumentResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "health.get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service health status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthData"];
                };
            };
        };
    };
    "documents.getIngestionStatus": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Ingestion ID (same as document ID) */
                ingestionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ingestion status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IngestionStatusResponse"];
                };
            };
            /** @description Ingestion not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.list": {
        parameters: {
            query?: {
                /** @description Filter by container tag. */
                containerTag?: string | null;
                /** @description Maximum results per page (default 20, max 100). */
                limit?: number | null;
                /** @description Opaque cursor for pagination. */
                cursor?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Memories listed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListMemoriesResponse"];
                };
            };
            /** @description Missing containerTag */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateMemoryRequest"];
            };
        };
        responses: {
            /** @description Memory created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MemoryResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Memory ID */
                memoryId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Memory found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MemoryResponse"];
                };
            };
            /** @description Memory not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.forgetById": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Memory ID */
                memoryId: string;
            };
            cookie?: never;
        };
        /** @description Optional reason for deletion */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ForgetMemoryRequest"];
            };
        };
        responses: {
            /** @description Memory forgotten */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ForgetMemoryResponse"];
                };
            };
            /** @description Memory not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Memory ID */
                memoryId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateMemoryRequest"];
            };
        };
        responses: {
            /** @description Memory updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateMemoryResponse"];
                };
            };
            /** @description Memory not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "graph.getMemory": {
        parameters: {
            query?: {
                /** @description Number of hops to traverse (default: 2). */
                depth?: number | null;
                /** @description Maximum number of memory nodes to return (default: 50). */
                maxNodes?: number | null;
                /** @description Comma-separated edge types to include (e.g. "updates,relatesto"). */
                relationTypes?: string | null;
            };
            header?: never;
            path: {
                /** @description Memory ID */
                memoryId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Graph neighborhood */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GraphResponse"];
                };
            };
            /** @description Memory not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "memories.forget": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentForgetRequest"];
            };
        };
        responses: {
            /** @description Memory forgotten */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ForgetMemoryResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "profile.compute": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ComputeProfileRequest"];
            };
        };
        responses: {
            /** @description Profile computed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
    "search.search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SearchRequest"];
            };
        };
        responses: {
            /** @description Search results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiError"];
                };
            };
        };
    };
}
